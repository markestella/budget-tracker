import { NextResponse } from 'next/server';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';
import { prisma } from '@/lib/prisma';
import { PaymentRecordGenerator } from '@/lib/paymentRecordGenerator';

export async function POST(request: Request) {
  try {
    const session = await getServerSession(authOptions);
    
    if (!session?.user?.email) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const user = await prisma.user.findUnique({
      where: { email: session.user.email },
    });

    if (!user) {
      return NextResponse.json({ error: 'User not found' }, { status: 404 });
    }

    const body = await request.json().catch(() => ({}));
    const { daysAhead = 90, action = 'generate' } = body;

    let result;

    switch (action) {
      case 'generate':
        // Generate upcoming payment records
        result = await PaymentRecordGenerator.generatePaymentRecordsForUser(user.id, daysAhead);
        break;
      
      case 'cleanup':
        // Clean up old overdue records
        result = await PaymentRecordGenerator.cleanupOverdueRecords(30);
        break;
        
      case 'cleanup-invalid':
        // Clean up invalid records with NaN or corrupted data
        result = await PaymentRecordGenerator.cleanupInvalidRecords();
        break;
      
      case 'update-dates':
        // Update next payment dates for all sources
        result = await PaymentRecordGenerator.updateNextPaymentDates();
        break;
      
      default:
        return NextResponse.json(
          { error: 'Invalid action. Use "generate", "cleanup", "cleanup-invalid", or "update-dates"' },
          { status: 400 }
        );
    }

    return NextResponse.json({
      action,
      success: true,
      ...result
    });

  } catch (error) {
    console.error('Error in payment generation API:', error);
    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    );
  }
}

export async function GET(request: Request) {
  try {
    const session = await getServerSession(authOptions);
    
    if (!session?.user?.email) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const user = await prisma.user.findUnique({
      where: { email: session.user.email },
    });

    if (!user) {
      return NextResponse.json({ error: 'User not found' }, { status: 404 });
    }

    // Get statistics about auto-generated payment records
    const autoGeneratedRecords = await prisma.incomeRecord.count({
      where: {
        incomeSource: { userId: user.id },
        notes: 'Auto-generated based on schedule configuration'
      }
    });

    const pendingAutoRecords = await prisma.incomeRecord.count({
      where: {
        incomeSource: { userId: user.id },
        status: 'PENDING',
        notes: 'Auto-generated based on schedule configuration'
      }
    });

    const overdueAutoRecords = await prisma.incomeRecord.count({
      where: {
        incomeSource: { userId: user.id },
        status: 'PENDING',
        notes: 'Auto-generated based on schedule configuration',
        expectedDate: {
          lt: new Date()
        }
      }
    });

    // Get next payment dates for active sources
    const activeSourcesWithNextPayment = await prisma.incomeSource.findMany({
      where: {
        userId: user.id,
        isActive: true,
        frequency: { not: 'ONE_TIME' },
        nextPaymentDate: { not: null }
      },
      select: {
        id: true,
        name: true,
        nextPaymentDate: true,
        amount: true
      },
      orderBy: {
        nextPaymentDate: 'asc'
      },
      take: 5
    });

    return NextResponse.json({
      statistics: {
        totalAutoGenerated: autoGeneratedRecords,
        pendingAutoGenerated: pendingAutoRecords,
        overdueAutoGenerated: overdueAutoRecords
      },
      upcomingScheduledPayments: activeSourcesWithNextPayment
    });

  } catch (error) {
    console.error('Error fetching payment generation info:', error);
    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    );
  }
}